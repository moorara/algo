package grammar

import (
	"bytes"
	"fmt"
	"strings"

	"github.com/moorara/algo/errors"
	"github.com/moorara/algo/generic"
	"github.com/moorara/algo/set"
	"github.com/moorara/algo/sort"
	"github.com/moorara/algo/symboltable"
)

var (
	primeSuffixes = []string{
		"‚Ä≤", // Prime U+2032
		"‚Ä≥", // Double Prime (U+2033)
		"‚Ä¥", // Triple Prime (U+2034)
		"‚Åó", // Quadruple Prime (U+2057)
	}

	alphabeticSuffixes = []string{
		"‚Çô", // Subscript Small N (U+2099)
		"‚Åø", // Superscript Small N (U+207F)
		"·¥∫", // Modifier Capital N (U+1D3A)
	}

	numericSuffixes = []string{
		// Subscript Zero (U+2080)
		"‚ÇÅ", // Subscript One (U+2081)
		"‚ÇÇ", // Subscript Two (U+2082)
		"‚ÇÉ", // Subscript Three (U+2083)
		"‚ÇÑ", // Subscript Four (U+2084)
		"‚ÇÖ", // Subscript Five (U+2085)
		"‚ÇÜ", // Subscript Six (U+2086)
		"‚Çá", // Subscript Seven (U+2087)
		"‚Çà", // Subscript Eight (U+2088)
		"‚Çâ", // Subscript Nine (U+2089)
		"‚ÇÅ‚ÇÄ", "‚ÇÅ‚ÇÅ", "‚ÇÅ‚ÇÇ", "‚ÇÅ‚ÇÉ", "‚ÇÅ‚ÇÑ", "‚ÇÅ‚ÇÖ", "‚ÇÅ‚ÇÜ", "‚ÇÅ‚Çá", "‚ÇÅ‚Çà", "‚ÇÅ‚Çâ",
		"‚ÇÇ‚ÇÄ", "‚ÇÇ‚ÇÅ", "‚ÇÇ‚ÇÇ", "‚ÇÇ‚ÇÉ", "‚ÇÇ‚ÇÑ", "‚ÇÇ‚ÇÖ", "‚ÇÇ‚ÇÜ", "‚ÇÇ‚Çá", "‚ÇÇ‚Çà", "‚ÇÇ‚Çâ",
		"‚ÇÉ‚ÇÄ", "‚ÇÉ‚ÇÅ", "‚ÇÉ‚ÇÇ", "‚ÇÉ‚ÇÉ", "‚ÇÉ‚ÇÑ", "‚ÇÉ‚ÇÖ", "‚ÇÉ‚ÇÜ", "‚ÇÉ‚Çá", "‚ÇÉ‚Çà", "‚ÇÉ‚Çâ",
		"‚ÇÑ‚ÇÄ", "‚ÇÑ‚ÇÅ", "‚ÇÑ‚ÇÇ", "‚ÇÑ‚ÇÉ", "‚ÇÑ‚ÇÑ", "‚ÇÑ‚ÇÖ", "‚ÇÑ‚ÇÜ", "‚ÇÑ‚Çá", "‚ÇÑ‚Çà", "‚ÇÑ‚Çâ",
		"‚ÇÖ‚ÇÄ", "‚ÇÖ‚ÇÅ", "‚ÇÖ‚ÇÇ", "‚ÇÖ‚ÇÉ", "‚ÇÖ‚ÇÑ", "‚ÇÖ‚ÇÖ", "‚ÇÖ‚ÇÜ", "‚ÇÖ‚Çá", "‚ÇÖ‚Çà", "‚ÇÖ‚Çâ",
		"‚ÇÜ‚ÇÄ", "‚ÇÜ‚ÇÅ", "‚ÇÜ‚ÇÇ", "‚ÇÜ‚ÇÉ", "‚ÇÜ‚ÇÑ", "‚ÇÜ‚ÇÖ", "‚ÇÜ‚ÇÜ", "‚ÇÜ‚Çá", "‚ÇÜ‚Çà", "‚ÇÜ‚Çâ",
		"‚Çá‚ÇÄ", "‚Çá‚ÇÅ", "‚Çá‚ÇÇ", "‚Çá‚ÇÉ", "‚Çá‚ÇÑ", "‚Çá‚ÇÖ", "‚Çá‚ÇÜ", "‚Çá‚Çá", "‚Çá‚Çà", "‚Çá‚Çâ",
		"‚Çà‚ÇÄ", "‚Çà‚ÇÅ", "‚Çà‚ÇÇ", "‚Çà‚ÇÉ", "‚Çà‚ÇÑ", "‚Çà‚ÇÖ", "‚Çà‚ÇÜ", "‚Çà‚Çá", "‚Çà‚Çà", "‚Çà‚Çâ",
		"‚Çâ‚ÇÄ", "‚Çâ‚ÇÅ", "‚Çâ‚ÇÇ", "‚Çâ‚ÇÉ", "‚Çâ‚ÇÑ", "‚Çâ‚ÇÖ", "‚Çâ‚ÇÜ", "‚Çâ‚Çá", "‚Çâ‚Çà", "‚Çâ‚Çâ",
	}
)

// CFG represents a context-free grammar in formal language theory.
//
// Context-free grammars can express a wide range of programming language constructs
// while remaining computationally efficient to parse.
// They are used in computer science and linguistics to describe the syntax of languages.
//
// A context-free grammar G = (V, Œ£, R, S) is defined by four sets:
//
//  1. V is a set of terminal symbols from which strings are formed.
//     Terminal symbols are also referred to as tokens.
//
//  2. Œ£ is a set of non-terminals symbols that denote sets of strings.
//     Non-terminal symbols are sometimes called syntactic variables.
//     Non-terminals impose a hierarchical structure on the language.
//
//  3. R = V √ó (V ‚à™ Œ£)* is a set of productions, where each production consists of
//     a non-terminal (head), an arrow, and a sequence of terminals and/or non-terminals (body).
//
//  4. S ‚àà V is one of the non-terminal symbols designated as the start symbol.
//     The set of strings denoted by the start symbol is the language generated by the grammar.
//
// Context-free languages are a superset of regular languages and they are more expressive.
type CFG struct {
	Terminals    set.Set[Terminal]
	NonTerminals set.Set[NonTerminal]
	Productions  Productions
	Start        NonTerminal
}

// NewCFG creates a new context-free grammar.
func NewCFG(terms []Terminal, nonTerms []NonTerminal, prods []Production, start NonTerminal) CFG {
	g := CFG{
		Terminals:    set.New(eqTerminal),
		NonTerminals: set.New(eqNonTerminal),
		Productions:  NewProductions(),
		Start:        start,
	}

	g.Terminals.Add(terms...)
	g.NonTerminals.Add(nonTerms...)
	g.Productions.Add(prods...)

	return g
}

// verify takes a context-free grammar and determines whether or not it is valid.
// If the given grammar is invalid, an error with a descriptive message will be returned.
func (g CFG) Verify() error {
	var err error

	getPredicate := func(n NonTerminal) generic.Predicate1[Production] {
		return func(p Production) bool {
			return p.Head.Equals(n)
		}
	}

	// Check if the start symbol is in the set of non-terminal symbols.
	if !g.NonTerminals.Contains(g.Start) {
		err = errors.Append(err, fmt.Errorf("start symbol %s not in the set of non-terminal symbols", g.Start))
	}

	// Check if there is at least one production rule for the start symbol.
	if !g.Productions.AnyMatch(getPredicate(g.Start)) {
		err = errors.Append(err, fmt.Errorf("no production rule for start symbol %s", g.Start))
	}

	// Check if there is at least one prodcution rule for every non-terminal symbol.
	for n := range g.NonTerminals.All() {
		if !g.Productions.AnyMatch(getPredicate(n)) {
			err = errors.Append(err, fmt.Errorf("no production rule for non-terminal symbol %s", n))
		}
	}

	for p := range g.Productions.All() {
		// Check if the head of production rule is in the set of non-terminal symbols.
		if !g.NonTerminals.Contains(p.Head) {
			err = errors.Append(err, fmt.Errorf("production head %s not in the set of non-terminal symbols", p.Head))
		}

		// Check if every symbol in the body of production rule is either in the set of terminal or non-terminal symbols.
		for _, s := range p.Body {
			if v, ok := s.(Terminal); ok && !g.Terminals.Contains(v) {
				err = errors.Append(err, fmt.Errorf("terminal symbol %s not in the set of terminal symbols", v))
			}

			if v, ok := s.(NonTerminal); ok && !g.NonTerminals.Contains(v) {
				err = errors.Append(err, fmt.Errorf("non-terminal symbol %s not in the set of non-terminal symbols", v))
			}
		}
	}

	return err
}

// String returns a string representation of a context-free grammar.
func (g CFG) String() string {
	var b bytes.Buffer

	terms := g.orderTerminals()
	visited, unvisited, nonTerms := g.orderNonTerminals()

	fmt.Fprintf(&b, "Terminal Symbols: %s\n", terms)
	fmt.Fprintf(&b, "Non-Terminal Symbols: %s\n", nonTerms)
	fmt.Fprintf(&b, "Start Symbol: %s\n", g.Start)
	fmt.Fprintln(&b, "Production Rules:")

	for _, head := range visited {
		fmt.Fprintf(&b, "  %s ‚Üí ", head)
		for _, p := range g.Productions.Order(head) {
			fmt.Fprintf(&b, "%s | ", p.Body.String())
		}
		b.Truncate(b.Len() - 3)
		fmt.Fprintln(&b)
	}

	for _, head := range unvisited {
		fmt.Fprintf(&b, "  %s ‚Üí ", head)
		for _, p := range g.Productions.Order(head) {
			fmt.Fprintf(&b, "%s | ", p.Body.String())
		}
		b.Truncate(b.Len() - 3)
		fmt.Fprintln(&b)
	}

	return b.String()
}

// Clone returns a deep copy of a context-free grammar, ensuring the clone is independent of the original.
func (g CFG) Clone() CFG {
	return CFG{
		Terminals:    g.Terminals.Clone(),
		NonTerminals: g.NonTerminals.Clone(),
		Productions:  g.Productions.Clone(),
		Start:        g.Start,
	}
}

// Equals determines whether or not two context-free grammars are the same.
func (g CFG) Equals(rhs CFG) bool {
	return g.Terminals.Equals(rhs.Terminals) &&
		g.NonTerminals.Equals(rhs.NonTerminals) &&
		g.Productions.Equals(rhs.Productions) &&
		g.Start.Equals(rhs.Start)
}

// IsCNF checks if a context-free grammar is in Chomsky Normal Form (CNF).
//
// A context-free grammar G is in Chomsky Normal Form (CNF) if all of its production rules are of the form
//
//   - A ‚Üí BC, or
//   - A ‚Üí a, or
//   - S ‚Üí Œµ
//
// where A, B, and C are non-terminal symbols, a is a terminal symbol, and S is the start symbol.
// Also, neither B nor C may be the start symbol, and the third production rule can only appear if Œµ is in L(G).
//
// The method returns nil if the grammar is in CNF,
// or an error detailing which production rules do not conform to CNF.
//
// The returned error is always an instance of errors.MultiError,
// which contains instances of CNFError, if the CFG is not in Chomsky Normal Form (CNF).
func (g CFG) IsCNF() error {
	var err = &errors.MultiError{
		Format: errors.BulletErrorFormat,
	}

	g.Productions.AllMatch(func(p Production) bool {
		isBinary, isTerminal := p.IsCNF()
		isStartEmpty := p.IsEmpty() && p.Head.Equals(g.Start)

		if !isBinary && !isTerminal && !isStartEmpty {
			err = errors.Append(err, &CNFError{P: p})
		}

		return true
	})

	return err.ErrorOrNil()
}

// IsLL1 checks if a context-free grammar (CFG) is an LL(1) grammar.
//
// LL(1) grammars are a subset of context-free grammars used in predictive parsing,
// a top-down parsing technique that uses recursive descent without backtracking.
//
//   - The first "L" indicates that the grammar is parsed from Left to right.
//   - The second "L" indicates that it produces a left-most derivation of the input string.
//   - The "1" means that the parser makes its decisions based on one input symbol of lookahead at each step.
//
// LL(1) grammars are expressive enough to cover most programming constructs.
// No left-recursive or ambiguous grammar can be LL(1).
//
// The method returns nil if the grammar is LL(1).
// It returns an error otherwise, providing details about what violates the LL(1) constraints.
//
// The returned error is always an instance of errors.MultiError,
// which contains instances of LL1Error, if the CFG is not LL(1).
func (g CFG) IsLL1() error {
	/*
	 * A grammar G is LL(1) if and only if whenever A ‚Üí Œ± | Œ≤ are two distinct productions of G,
	 * the following conditions hold:
	 *
	 *   1. For no terminal a do both Œ± and Œ≤ derive strings beginning with a.
	 *   2. At most one of Œ± and Œ≤ can derive the empty string Œµ.
	 *   3. If Œ± ‚áí* Œµ then Œ≤ does not derive any string beginning with a terminal in FOLLOW(A).
	 *      Likewise, if Œ≤ ‚áí* Œµ, then Œ± does not derive any string beginning with a terminal in FOLLOW(A).
	 *
	 * The first two conditions are equivalent to FIRST(Œ±) and FIRST(Œ≤) are disjoint sets.
	 * The third condition is equivalent to if Œµ ‚àà FIRST(Œ±), then FIRST(Œ≤) and FOLLOW(A) are disjoint sets,
	 * and likewise if Œµ ‚àà FIRST(Œ≤), then FIRST(Œ±) and FOLLOW(A) are disjoint sets.
	 */

	var err = &errors.MultiError{
		Format: errors.BulletErrorFormat,
	}

	first := g.ComputeFIRST()
	follow := g.ComputeFOLLOW(first)

	for A := range g.Productions.AllByHead() {

		// The order in which production bodies are processed does not affect the outcome.
		// Sorting is only done to make error messages deterministic and easier to understand.
		prods := g.Productions.Order(A)

		for i := 0; i < len(prods); i++ {
			for j := i + 1; j < len(prods); j++ {
				Œ±, Œ≤ := prods[i].Body, prods[j].Body
				firstŒ±, firstŒ≤, followA := first(Œ±), first(Œ≤), follow(A)

				/* Check FIRST(Œ±) ‚à© FIRST(Œ≤) = ‚àÖ */

				if !firstŒ±.Terminals.Intersection(firstŒ≤.Terminals).IsEmpty() || firstŒ±.IncludesEmpty && firstŒ≤.IncludesEmpty {
					err = errors.Append(err, &LL1Error{
						Description: "FIRST(Œ±) and FIRST(Œ≤) are not disjoint sets",
						A:           A,
						Alpha:       Œ±,
						Beta:        Œ≤,
						FIRSTŒ±:      &firstŒ±,
						FIRSTŒ≤:      &firstŒ≤,
					})
				}

				// Check if Œµ ‚àà FIRST(Œ±), then FIRST(Œ≤) ‚à© FOLLOW(A) = ‚àÖ
				if firstŒ±.IncludesEmpty && !firstŒ≤.Terminals.Intersection(followA.Terminals).IsEmpty() {
					err = errors.Append(err, &LL1Error{
						Description: "Œµ is in FIRST(Œ±), but FOLLOW(A) and FIRST(Œ≤) are not disjoint sets",
						A:           A,
						Alpha:       Œ±,
						Beta:        Œ≤,
						FOLLOWA:     &followA,
						FIRSTŒ±:      &firstŒ±,
						FIRSTŒ≤:      &firstŒ≤,
					})
				}

				// Check if Œµ ‚àà FIRST(Œ≤), then FIRST(Œ±) ‚à© FOLLOW(A) = ‚àÖ
				if firstŒ≤.IncludesEmpty && !firstŒ±.Terminals.Intersection(followA.Terminals).IsEmpty() {
					err = errors.Append(err, &LL1Error{
						Description: "Œµ is in FIRST(Œ≤), but FOLLOW(A) and FIRST(Œ±) are not disjoint sets",
						A:           A,
						Alpha:       Œ±,
						Beta:        Œ≤,
						FOLLOWA:     &followA,
						FIRSTŒ±:      &firstŒ±,
						FIRSTŒ≤:      &firstŒ≤,
					})
				}
			}
		}
	}

	return err.ErrorOrNil()
}

// NullableNonTerminals finds all non-terminals in a context-free grammar
// that can derive the empty string Œµ in one or more steps (A ‚áí* Œµ for some non-terminal A).
func (g CFG) NullableNonTerminals() set.Set[NonTerminal] {
	// Define a set for all non-terminals that can derive the empty string Œµ
	nullable := set.New(eqNonTerminal)

	for updated := true; updated; {
		updated = false

		// Iterate through each production rule of the form A ‚Üí Œ±,
		// where A is a non-terminal symbol and Œ± is a string of terminals and non-terminals.
		for head, list := range g.Productions.AllByHead() {
			// Skip the production rule if A is already in the nullable set.
			if nullable.Contains(head) {
				continue
			}

			for p := range list.All() {
				if p.IsEmpty() {
					// Œ± is the empty string Œµ, add A to the nullable set.
					nullable.Add(p.Head)
					updated = true
				} else if n := p.Body.NonTerminals(); len(n) == len(p.Body) && nullable.Contains(n...) {
					// Œ± consists of only non-terminal symbols already in the nullable set, add A to the nullable set.
					nullable.Add(p.Head)
					updated = true
				}
			}
		}
	}

	return nullable
}

// EliminateEmptyProductions converts a context-free grammar into an equivalent Œµ-free grammar.
//
// An empty production (Œµ-production) is any production of the form A ‚Üí Œµ.
func (g CFG) EliminateEmptyProductions() CFG {
	nullable := g.NullableNonTerminals()

	newG := CFG{
		Terminals:    g.Terminals.Clone(),
		NonTerminals: g.NonTerminals.Clone(),
		Productions:  NewProductions(),
		Start:        g.Start,
	}

	// Iterate through each production rule in the input grammar.
	// For each production rule of the form A ‚Üí Œ±,
	//   generate all possible combinations of Œ± by including and excluding nullable non-terminals.
	for p := range g.Productions.All() {
		// Ignore Œµ-production rules (A ‚Üí Œµ)
		// Only consider the production rules of the form A ‚Üí Œ±
		if p.IsEmpty() {
			continue
		}

		// bodies holds all possible combinations of the right-hand side of a production rule.
		bodies, aux := []String[Symbol]{Œµ}, []String[Symbol]{}

		// Every nullable non-terminal symbol creates two possibilities, once by including and once by excluding it.
		for _, sym := range p.Body {
			v, ok := sym.(NonTerminal)
			nonTermNullable := ok && nullable.Contains(v)

			for _, Œ≤ := range bodies {
				if nonTermNullable {
					aux = append(aux, Œ≤)
				}
				aux = append(aux, append(Œ≤, sym))
			}

			bodies, aux = aux, nil
		}

		for _, Œ≤ := range bodies {
			// Skip Œµ-production rules (A ‚Üí Œµ)
			if len(Œ≤) > 0 {
				newG.Productions.Add(Production{p.Head, Œ≤})
			}
		}
	}

	// The set data structure automatically prevents duplicate items from being added.
	// Therefore, we don't need to worry about deduplicating the new production rules at this stage.

	// If the start symbol of the grammer is nullable (S ‚áí* Œµ),
	//   a new start symbol with an Œµ-production rule must be introduced (S‚Ä≤ ‚Üí S | Œµ).
	// This guarantees that the resulting grammar generates the same language as the original grammar.
	if start := newG.Start; nullable.Contains(start) {
		newStart := newG.addNewNonTerminal(start, primeSuffixes...)
		newG.Start = newStart
		newG.Productions.Add(Production{newStart, String[Symbol]{start}}) // S‚Ä≤ ‚Üí S
		newG.Productions.Add(Production{newStart, Œµ})                     // S‚Ä≤ ‚Üí Œµ
	}

	return newG
}

// EliminateSingleProductions converts a context-free grammar into an equivalent single-production-free grammar.
//
// A single production a.k.a. unit production is a production rule whose body is a single non-terminal symbol (A ‚Üí B).
func (g CFG) EliminateSingleProductions() CFG {
	// Identify all single productions.
	singleProds := map[NonTerminal][]NonTerminal{}
	for p := range g.Productions.All() {
		if p.IsSingle() {
			singleProds[p.Head] = append(singleProds[p.Head], p.Body[0].(NonTerminal))
		}
	}

	// Compute the transitive closure for all non-terminal symbols.
	// The transitive closure of a non-terminal A is the the set of all non-terminals B
	//   such that there exists a sequence of single productions starting from A and reaching B (i.e., A ‚Üí B‚ÇÅ ‚Üí B‚ÇÇ ‚Üí ... ‚Üí B).

	closure := make(map[NonTerminal]map[NonTerminal]bool, g.NonTerminals.Size())

	// Initially, each non-terminal symbol is reachable from itself.
	for A := range g.NonTerminals.All() {
		closure[A] = map[NonTerminal]bool{A: true}
	}

	// Next, add directly reachable non-terminal symbols from single productions.
	for A, nonTerms := range singleProds {
		for _, B := range nonTerms {
			closure[A][B] = true
		}
	}

	// Repeat until no new non-terminal symbols can be added to the closure set.
	for updated := true; updated; {
		updated = false

		for A, closureA := range closure {
			for B := range closureA {
				for next := range closure[B] {
					if !closureA[next] {
						closure[A][next] = true
						updated = true
					}
				}
			}
		}
	}

	newG := CFG{
		Terminals:    g.Terminals.Clone(),
		NonTerminals: g.NonTerminals.Clone(),
		Productions:  NewProductions(),
		Start:        g.Start,
	}

	// For each production rule p of the form B ‚Üí Œ±, add a new production rule A ‚Üí Œ±
	//   if p is not a single production and B is in the transitive closure set of A.
	for A, closureA := range closure {
		for B := range closureA {
			for p := range g.Productions.Get(B).All() {
				// Skip single productions
				if !p.IsSingle() {
					newG.Productions.Add(Production{A, p.Body})
				}
			}
		}
	}

	return newG
}

// EliminateUnreachableProductions converts a context-free grammar into an equivalent grammar
// with all unreachable productions and their associated non-terminal symbols removed.
//
// An unreachable production refers to a production rule in a grammar
// that cannot be used to derive any string starting from the start symbol.
//
// The function also removes unreachable terminals,
// which are terminals that do not appear in any reachable production.
func (g CFG) EliminateUnreachableProductions() CFG {
	reachableT := set.New(eqTerminal)
	reachableN := set.New(eqNonTerminal, g.Start)
	reachableP := NewProductions()

	// Reppeat until no new non-terminal is added to reachable non-terminals:
	//   For each production rule of the form A ‚Üí Œ±:
	//     If A is in reachable non-terminals, add all non-terminal in Œ± to reachable non-terminals too.
	for updated := true; updated; {
		updated = false

		for p := range g.Productions.All() {
			if reachableN.Contains(p.Head) {
				for _, n := range p.Body.NonTerminals() {
					if !reachableN.Contains(n) {
						reachableN.Add(n)
						updated = true
					}
				}
			}
		}
	}

	// Gather reachable productions.
	for p := range g.Productions.All() {
		if reachableN.Contains(p.Head) {
			reachableP.Add(p)
		}
	}

	// Gather reachable terminals.
	for t := range g.Terminals.All() {
		if reachableP.AnyMatch(func(p Production) bool {
			return p.Body.ContainsSymbol(t)
		}) {
			reachableT.Add(t)
		}
	}

	return CFG{
		Terminals:    reachableT,
		NonTerminals: reachableN,
		Productions:  reachableP,
		Start:        g.Start,
	}
}

// EliminateCycles converts a context-free grammar into an equivalent cycle-free grammar.
//
// A grammar is cyclic if it has derivations of one or more steps in which A ‚áí* A for some non-terminal A.
func (g CFG) EliminateCycles() CFG {
	// Single productions (unit productions) can create cycles in a grammar.
	// Eliminating empty productions (Œµ-productions) may introduce additional single productions,
	// so it is necessary to eliminate empty productions first, followed by single productions.
	// After removing single productions, some productions may become unreachable.
	// These unreachable productions should then be removed from the grammar.
	return g.EliminateEmptyProductions().EliminateSingleProductions().EliminateUnreachableProductions()
}

// EliminateLeftRecursion converts a context-free grammar into an equivalent grammar with no left recursion.
//
// A grammar is left-recursive if it has a non-terminal A such that there is a derivation A ‚áí+ AŒ± for some string.
// For top-down parsers, left recursion causes the parser to loop forever.
// Many bottom-up parsers also will not accept left-recursive grammars.
//
// Note that the resulting non-left-recursive grammar may have Œµ-productions.
func (g CFG) EliminateLeftRecursion() CFG {
	// Define predicates for identifying left-recursive and non-left-recursive productions
	isLeftRecursivePredicate := func(p Production) bool { return p.IsLeftRecursive() }
	isNotLeftRecursivePredicate := func(p Production) bool { return !p.IsLeftRecursive() }

	// The algorithm implemented here is guaranteed to work if the grammar has no cycles or Œµ-productions.
	newG := g.EliminateCycles()

	// Arrange the non-terminals in some order.
	// The exact order does not affect the eliminition of left recursions (immediate or indirect),
	//   but the resulting grammar can depend on the order in which non-terminals are processed.
	_, _, nonTerms := newG.orderNonTerminals()

	for i := 0; i < len(nonTerms); i++ {
		for j := 0; j < i-1; j++ {
			/*
			 * Replace each production of the form A·µ¢ ‚Üí A‚±ºŒ≥ by the productions A·µ¢ ‚Üí Œ¥‚ÇÅŒ≥ | Œ¥‚ÇÇŒ≥ | ... | Œ¥‚ÇñŒ≥,
			 * where A‚±º ‚Üí Œ¥‚ÇÅ | Œ¥‚ÇÇ | ... | Œ¥‚Çñ are all current A‚±º-productions.
			 */

			Ai, Aj := nonTerms[i], nonTerms[j]
			AiProds, AjProds := newG.Productions.Get(Ai), newG.Productions.Get(Aj)

			AiAjProds := AiProds.SelectMatch(func(p Production) bool {
				return len(p.Body) > 0 && p.Body[0].Equals(Aj)
			})

			for AiAjProd := range AiAjProds.All() {
				newG.Productions.Remove(AiAjProd)
				for AjProd := range AjProds.All() {
					p := Production{Ai, AjProd.Body.Concat(AiAjProd.Body[1:])}
					newG.Productions.Add(p)
				}
			}
		}

		/*
		 * Immediate left recursion can be eliminated by the following technique,
		 * which works for any number of A-productions.
		 *
		 * First, group the productions as
		 *
		 *   A ‚Üí AŒ±‚ÇÅ | AŒ±‚ÇÇ | ... | AŒ±‚Çò | Œ≤‚ÇÅ | Œ≤‚ÇÇ | ... | Œ≤‚Çô
		 *
		 * where no Œ±·µ¢ is Œµ and no Œ≤·µ¢ begins with an A. Then replace A-productions by
		 *
		 *    A ‚Üí Œ≤‚ÇÅA‚Ä≤ | Œ≤‚ÇÇA‚Ä≤ | ... | Œ≤‚ÇôA‚Ä≤
		 *    A‚Ä≤ ‚Üí Œ±‚ÇÅA‚Ä≤ | Œ±‚ÇÇA‚Ä≤ | ... | Œ±‚ÇòA‚Ä≤ | Œµ
		 */

		A := nonTerms[i]
		AProds := newG.Productions.Get(A)
		hasLR := AProds.AnyMatch(isLeftRecursivePredicate)

		if hasLR {
			Anew := newG.addNewNonTerminal(A, primeSuffixes...)

			LRProds := AProds.SelectMatch(isLeftRecursivePredicate)       // Immediately Left-Recursive A-productions
			nonLRProds := AProds.SelectMatch(isNotLeftRecursivePredicate) // Not Immediately Left-Recursive A-productions

			// Remove A ‚Üí AŒ±‚ÇÅ | AŒ±‚ÇÇ | ... | AŒ±‚Çò | Œ≤‚ÇÅ | Œ≤‚ÇÇ | ... | Œ≤‚Çô
			newG.Productions.RemoveAll(A)

			// Add A ‚Üí Œ≤‚ÇÅA‚Ä≤ | Œ≤‚ÇÇA‚Ä≤ | ... | Œ≤‚ÇôA‚Ä≤
			for nonLRProd := range nonLRProds.All() {
				newG.Productions.Add(Production{A, nonLRProd.Body.Append(Anew)})
			}

			// Single productions of the form A ‚Üí A, where Œ± = Œµ, are already eliminated.
			// Add A‚Ä≤ ‚Üí Œ±‚ÇÅA‚Ä≤ | Œ±‚ÇÇA‚Ä≤ | ... | Œ±‚ÇòA‚Ä≤ | Œµ
			for LRProd := range LRProds.All() {
				newG.Productions.Add(Production{Anew, LRProd.Body[1:].Append(Anew)})
			}

			// Add A‚Ä≤ ‚Üí Œµ
			newG.Productions.Add(Production{Anew, Œµ})
		}
	}

	return newG
}

// LeftFactor converts a context-free grammar into an equivalent left-factored grammar.
//
// Left factoring is a grammar transformation for producing a grammar suitable predictive for top-down parsing.
// When the choice between two alternative A-productions is not clear,
// we may be able to rewrite the productions to defer the decision
// until enough of the input has been seen that we can make the right choice.
//
// For example, if we have the two productions
//
//	ùë†ùë°ùëöùë° ‚Üí ùê¢ùêü ùëíùë•ùëùùëü ùê≠ùê°ùêûùêß ùë†ùë°ùëöùë° ùêûùê•ùê¨ùêû ùë†ùë°ùëöùë°
//	    | ùê¢ùêü ùëíùë•ùëùùëü ùê≠ùê°ùêûùêß ùë†ùë°ùëöùë°
//
// on seeing the input ùê¢ùêü, we cannot immediately tell which productions to choose to expand ùë†ùë°ùëöùë°.
//
// Note that the resulting  left-factored grammar may have Œµ-productions and/or single productions.
func (g CFG) LeftFactor() CFG {
	/*
	 * For each non-terminal A, find the longest prefix Œ± common to two or more A-productions.
	 * If Œ± ‚â† Œµ, there is a non-trivial common prefix, replace all of the A-productions
	 *
	 *   A ‚Üí Œ±Œ≤‚ÇÅ | Œ±Œ≤‚ÇÇ | ... | Œ±Œ≤‚Çô | Œ≥
	 *
	 * where Œ≥ represents all the alternative productions that do not being with Œ±, by
	 *
	 *   A ‚Üí Œ±A‚Ä≤ | Œ≥
	 *   A‚Ä≤ ‚Üí Œ≤‚ÇÅ | Œ≤‚ÇÇ | ... | Œ≤‚Çô
	 *
	 * We repeatedly apply this transformation until
	 * no two alternative productions for a non-terminal have a common prefix.
	 */

	newG := g.Clone()

	for updated := true; updated; {
		updated = false

		for A, AProds := range newG.Productions.AllByHead() {
			// Group production bodies by their common prefixes.
			groups := groupByCommonPrefix(AProds)

			// Select groups with two or more suffixes.
			// These correspond to A-productions A ‚Üí Œ±Œ≤‚ÇÅ | Œ±Œ≤‚ÇÇ | ... | Œ±Œ≤‚Çô
			prefixGroups := groups.SelectMatch(func(prefix String[Symbol], suffixes set.Set[String[Symbol]]) bool {
				return suffixes.Size() >= 2
			})

			// Select groups with exactly one suffix.
			// These correspond to alternative A-productions A ‚Üí Œ≥
			altGroups := groups.SelectMatch(func(prefix String[Symbol], suffixes set.Set[String[Symbol]]) bool {
				return suffixes.Size() == 1
			})

			if prefixGroups.Size() > 0 && altGroups.Size() > 0 {
				// Remove all A-productions A ‚Üí Œ±Œ≤‚ÇÅ | Œ±Œ≤‚ÇÇ | ... | Œ±Œ≤‚Çô | Œ≥
				AProds.RemoveAll()

				for prefix, suffixes := range prefixGroups.All() {
					Anew := newG.addNewNonTerminal(A, primeSuffixes...)

					// Add A-production A ‚Üí Œ±A‚Ä≤
					newG.Productions.Add(Production{A, prefix.Append(Anew)})

					// Add A‚Ä≤-productions A‚Ä≤ ‚Üí Œ≤‚ÇÅ | Œ≤‚ÇÇ | ... | Œ≤‚Çô
					for suffix := range suffixes.All() {
						newG.Productions.Add(Production{Anew, suffix})
					}
				}

				// Add alternative A-productions A ‚Üí Œ≥
				for prefix, suffixes := range altGroups.All() {
					for suffix := range suffixes.All() {
						newG.Productions.Add(Production{A, prefix.Concat(suffix)})
					}
				}
			}
		}
	}

	return newG
}

// groupByCommonPrefix groups production bodies by their common prefixes.
// It prioritizes shorter prefixes that encompass more suffixes and production bodies
// over longer prefixes that encompass fewer suffixes or production bodies.
func groupByCommonPrefix(prods set.Set[Production]) symboltable.SymbolTable[String[Symbol], set.Set[String[Symbol]]] {
	// Define a map of prefixes to their corresponding suffixes.
	groups := symboltable.NewQuadraticHashTable(hashString, eqString, eqStringSet, symboltable.HashOpts{})

	for prod := range prods.All() {
		prefixFound := false

		// Attempt to find an existing prefix for the current production body.
		for prefix := range groups.All() {
			// Compute the longest common prefix between the current production body and an existing prefix in the groups.
			commonPrefix := String[Symbol]{}
			for i := 0; i < len(prefix) && i < len(prod.Body) && prefix[i].Equals(prod.Body[i]); i++ {
				commonPrefix = commonPrefix.Append(prefix[i])
			}

			// If a common prefix is found,
			// add the remaining part of the current production body as a suffix to the prefix group.
			if len(commonPrefix) > 0 {
				suffix := prod.Body[len(commonPrefix):]
				suffixes, _ := groups.Get(commonPrefix)
				suffixes.Add(suffix)
				prefixFound = true
				break
			}
		}

		// If no matching prefix is found,
		// initialize a new prefix with the first symbol of the production body and store the remaining part as the suffix.
		if !prefixFound {
			var prefix, suffix String[Symbol]
			if prod.IsEmpty() {
				prefix, suffix = Œµ, Œµ
			} else {
				prefix, suffix = prod.Body[:1], prod.Body[1:]
			}

			suffixes := set.New(eqString, suffix)
			groups.Put(prefix, suffixes)
		}
	}

	return groups
}

// ChomskyNormalForm converts a context-free grammar into an equivalent grammar in Chomsky Normal Form.
//
// A context-free grammar G is in Chomsky Normal Form (CNF) if all of its production rules are of the form
//
//   - A ‚Üí BC, or
//   - A ‚Üí a, or
//   - S ‚Üí Œµ
//
// where A, B, and C are non-terminal symbols, a is a terminal symbol, and S is the start symbol.
// Also, neither B nor C may be the start symbol, and the third production rule can only appear if Œµ is in L(G).
func (g CFG) ChomskyNormalForm() CFG {
	/*
	 * The order in which these transformations are applied is critical.
	 * Some transformations may undo the effects of other ones.
	 *
	 * The blow-up in grammar size depends on the order between DEL and BIN.
	 * It may be exponential when DEL is applied first, but is linear otherwise.
	 * UNIT can incur a quadratic blow-up in the size of the grammar.
	 *
	 * The orderings START,TERM,BIN,DEL,UNIT and START,BIN,DEL,UNIT,TERM lead to
	 *   the least blow-up in grammar size while preserving the results of previous transformations.
	 */

	return g.eliminateStartSymbolFromRight(). // START
							eliminateNonSolitaryTerminals(). // TERM
							eliminateNonBinaryProductions(). // BIN
							EliminateEmptyProductions().     // DEL
							EliminateSingleProductions().    // UNIT
							EliminateUnreachableProductions()
}

// eliminateStartSymbolFromRight eliminate the start symbol from the right-hand side of any production rules
// by introducing a new start symbol S‚Ä≤ and add the production rule S‚Ä≤ ‚Üí S.
func (g CFG) eliminateStartSymbolFromRight() CFG {
	newG := g.Clone()

	if S := newG.Start; newG.Productions.AnyMatch(func(p Production) bool {
		return p.Body.ContainsSymbol(S)
	}) {
		Snew := newG.addNewNonTerminal(S, primeSuffixes...)
		newG.Start = Snew
		newG.Productions.Add(Production{Snew, String[Symbol]{S}})
	}

	return newG
}

// eliminateNonSolitaryTerminals eliminate production rules with non-solitary terminals.
// It replaces terminals mixed with non-terminals in productions by introducing intermediate non-terminals.
func (g CFG) eliminateNonSolitaryTerminals() CFG {
	store := map[Terminal]NonTerminal{}

	newG := CFG{
		Terminals:    g.Terminals.Clone(),
		NonTerminals: g.NonTerminals.Clone(),
		Productions:  NewProductions(),
		Start:        g.Start,
	}

	for p := range g.Productions.All() {
		// Skip productions of the form A ‚Üí a.
		if _, isTerminal := p.IsCNF(); isTerminal {
			newG.Productions.Add(p)
			continue
		}

		var newBody String[Symbol]
		for _, sym := range p.Body {
			if t, ok := sym.(Terminal); ok {
				newN, exist := store[t]
				if !exist {
					newN = newG.addNewNonTerminal(NonTerminal(t), alphabeticSuffixes...)
					store[t] = newN
				}

				newBody = append(newBody, newN)
				newG.Productions.Add(Production{newN, String[Symbol]{sym}})
			} else {
				newBody = append(newBody, sym)
			}
		}

		newG.Productions.Add(Production{p.Head, newBody})
	}

	return newG
}

// eliminateNonBinaryProductions eliminates production rules with more than two non-terminals in their right-hand sides.
// It replaces each production with a right-hand side longer than two non-terminals with intermediate non-terminals.
func (g CFG) eliminateNonBinaryProductions() CFG {
	newG := CFG{
		Terminals:    g.Terminals.Clone(),
		NonTerminals: g.NonTerminals.Clone(),
		Productions:  NewProductions(),
		Start:        g.Start,
	}

	for A := range g.Productions.AllByHead() {
		for _, p := range g.Productions.Order(A) {
			// Skip Œµ-production, single productions and productions already in CNF (A ‚Üí BC or A ‚Üí a).
			if isBinary, isTerminal := p.IsCNF(); isTerminal || isBinary || p.IsEmpty() || p.IsSingle() {
				newG.Productions.Add(p)
				continue
			}

			/*
			 * Replace each production
			 *
			 *   A ‚Üí X‚ÇÅ X‚ÇÇ ... X‚Çô
			 *
			 * with more than two non-terminals X‚ÇÅ, X‚ÇÇ, ..., X‚Çô by rules
			 *
			 *   A ‚Üí X‚ÇÅ A‚ÇÅ
			 *   A‚ÇÅ ‚Üí X‚ÇÇ A‚ÇÇ
			 *   ...
			 *   A‚Çô‚Çã‚ÇÇ ‚Üí X‚Çô‚Çã‚ÇÅ X‚Çô
			 */

			for head, i := A, 0; i <= len(p.Body)-2; i++ {
				if i == len(p.Body)-2 {
					newG.Productions.Add(Production{head, p.Body[i:]})
				} else {
					headN := newG.addNewNonTerminal(A, numericSuffixes...)
					newG.Productions.Add(Production{head, p.Body[i : i+1].Append(headN)})
					head = headN
				}
			}
		}
	}

	return newG
}

// ComputeFIRST returns the FIRST function for a context-free grammar.
// The returned function memoizes the FIRST(X) for all grammar symbols (terminals and non-terminals).
// It will compute FIRST(Œ±) based on the pre-computed FIRST(X) and memoize the result.
//
// FIRST(Œ±), where Œ± is any string of grammar symbols (terminals and non-terminals),
// is the set of terminals that begin strings derived from Œ±.
// If Œ± ‚áí* Œµ, then Œµ is also in FIRST(Œ±).
func (g CFG) ComputeFIRST() FIRST {
	/*
	 * To compute FIRST(X) for all grammar symbols (terminals and non-terminals),
	 * we apply the following rules until no more terminals or Œµ can be added to any FIRST set.
	 *
	 *   1. If X is a terminal, then FIRST(X) = {X}.
	 *   2. If X is a non-terminal and X ‚Üí Y‚ÇÅY‚ÇÇ...Y‚Çñ is a production for some k ‚â• 1,
	 *      then place ùëé in FIRST(X) if for some i, ùëé is in FIRST(Y·µ¢), and Œµ is in all of
	 *      FIRST(Y‚ÇÅ), FIRST(Y‚ÇÇ), ..., FIRST(Y·µ¢‚Çã‚ÇÅ); that is Y‚ÇÅY‚ÇÇ...Y·µ¢‚Çã‚ÇÅ ‚áí* Œµ. If Œµ is in
	 *      FIRST(Y·µ¢) for all i = 1, 2, ..., k, then add Œµ to FIRST(X).
	 *   3. If X ‚Üí Œµ is a production, then add Œµ to FIRST(X).
	 *
	 * Now, we can compute FIRST for any string X‚ÇÅX‚ÇÇ...X‚Çô as follows.
	 * Add to FIRST(X‚ÇÅX‚ÇÇ...X‚Çô):
	 *
	 *   ‚Ä¢ All non-Œµ symbols of FIRST(X‚ÇÅ)
	 *   ‚Ä¢ Add the non-Œµ symbols of FIRST(X‚ÇÇ), if Œµ is in FIRST(X‚ÇÅ)
	 *   ‚Ä¢ Add the non-Œµ symbols of FIRST(X‚ÇÉ), if Œµ is in FIRST(X‚ÇÅ) and FIRST(X‚ÇÇ)
	 *   ‚Ä¢ ...
	 *   ‚Ä¢ Finally add Œµ if for all i = 1, 2, ..., n, Œµ is in FIRST(X·µ¢)
	 */

	firstBySymbol, firstByString := newFirstBySymbolTable(), newFirstByStringTable()

	// Compute FIRST(X) for all terminals.
	for X := range g.Terminals.All() {
		firstBySymbol.Put(X, newTerminalsAndEmpty(X))
	}

	// Initialize FIRST(X) for all non-terminals.
	for X := range g.NonTerminals.All() {
		firstBySymbol.Put(X, newTerminalsAndEmpty())
	}

	// If a production rule for non-terminal A has A in its body,
	// we need to process the A-productions multiple times until FIRST(A) no longer changes.
	for updated := true; updated; {
		updated = false

		// Compute FIRST(X) for all non-terminals.
		for X, prods := range g.Productions.AllByHead() {
			for p := range prods.All() {
				firstX, _ := firstBySymbol.Get(X)

				// Add Œµ to FIRST(X) if X ‚Üí Œµ.
				if p.IsEmpty() {
					updated = updated || !firstX.IncludesEmpty
					firstX.IncludesEmpty = true
					continue
				}

				// Update FIRST(X) based on X ‚Üí Y‚ÇÅY‚ÇÇ...Y‚Çñ.
				allIncludesEmpty := true
				for _, Y := range p.Body {
					firstY, _ := firstBySymbol.Get(Y)

					preSize := firstX.Terminals.Size()
					firstX.Terminals = firstX.Terminals.Union(firstY.Terminals)
					updated = updated || firstX.Terminals.Size() > preSize

					if !firstY.IncludesEmpty {
						allIncludesEmpty = false
						break
					}
				}

				// Add Œµ to FIRST(X) if Œµ ‚àà FIRST(Y·µ¢) for all Y·µ¢.
				updated = updated || (allIncludesEmpty && !firstX.IncludesEmpty)
				firstX.IncludesEmpty = firstX.IncludesEmpty || allIncludesEmpty
			}
		}
	}

	return func(s String[Symbol]) TerminalsAndEmpty {
		if f, ok := firstByString.Get(s); ok {
			return *f
		}

		firstS := newTerminalsAndEmpty()
		firstByString.Put(s, firstS)

		// Update FIRST(X) based on X ‚Üí Y‚ÇÅY‚ÇÇ...Y‚Çñ.
		allIncludesEmpty := true
		for _, X := range s {
			f, ok := firstBySymbol.Get(X)
			if !ok {
				panic(fmt.Sprintf("undefined grammar symbol %s", X))
			}

			firstS.Terminals = firstS.Terminals.Union(f.Terminals)

			if !f.IncludesEmpty {
				allIncludesEmpty = false
				break
			}
		}

		// Add Œµ to FIRST(X) if Œµ ‚àà FIRST(Y·µ¢) for all Y·µ¢.
		if allIncludesEmpty {
			firstS.IncludesEmpty = true
		}

		return *firstS
	}
}

// ComputeFOLLOW returns the FOLLOW function for a context-free grammar.
// The returned function memoizes the FOLLOW(A) for all non-terminals A.
//
// FOLLOW(A), for non-terminal A, is the set of terminals ùëé
// that can appear immediately to the right of A in some sentential form;
// that is; the set of terminals ùëé such that there exists a derivation of the form S ‚áí* Œ±AaŒ≤
// for some Œ± and Œ≤ strings of grammar symbols (terminals and non-terminals).
func (g CFG) ComputeFOLLOW(first FIRST) FOLLOW {
	/*
	 * To compute FOLLOW(A) for all non-terminals A,
	 * we apply the following rules until no more terminals can be added to any FOLLOW set.
	 *
	 *   1. Place $ in FOLLOW(S), where S is the start symbol, and $ is the input right endmarker.
	 *   2. If there is a production A ‚Üí Œ±BŒ≤, then everything in FIRST(Œ≤) except Œµ is in FOLLOW(B).
	 *   3. If there is a production A ‚Üí Œ±B, or a production A ‚Üí Œ±BŒ≤ where FIRST(Œ≤) contains Œµ,
	 *      then everything in FOLLOW(A) is in FOLLOW(B).
	 */

	follow := newFollowTable()

	// Initialize FOLLOW sets.
	for B := range g.NonTerminals.All() {
		follow.Put(B, newTerminalsAndEndmarker())
	}

	// Add the special endmarker symbol to the FOLLOW(S).
	followS, _ := follow.Get(g.Start)
	followS.IncludesEndmarker = true

	// Compute FOLLOW(B) for all non-terminals.
	for updated := true; updated; {
		updated = false

		for A, AProds := range g.Productions.AllByHead() {
			for p := range AProds.All() {
				for i, X := range p.Body {
					if B, ok := X.(NonTerminal); ok {
						// A ‚Üí Œ±BŒ≤
						// Œ± := p.Body[:i]
						Œ≤ := p.Body[i+1:]

						firstŒ≤ := first(Œ≤)
						followB, _ := follow.Get(B)

						// Add everything in FIRST(Œ≤) except Œµ to FOLLOW(B).
						preSize := followB.Terminals.Size()
						followB.Terminals = followB.Terminals.Union(firstŒ≤.Terminals)
						updated = updated || followB.Terminals.Size() > preSize

						// If A ‚Üí Œ±BŒ≤ where Œ≤ = Œµ or Œµ ‚àà FIRST(Œ≤), then FIRST(Œ≤) = {Œµ} (FIRST(Œµ) = {Œµ}).
						if firstŒ≤.IncludesEmpty {
							followA, _ := follow.Get(A)

							// Add everything in FOLLOW(A) to FOLLOW(B).
							preSize := followB.Terminals.Size()
							followB.Terminals = followB.Terminals.Union(followA.Terminals)
							updated = updated || followB.Terminals.Size() > preSize

							// Add Œµ to FIRST(X) if Œµ ‚àà FIRST(Y·µ¢) for all Y·µ¢.
							updated = updated || (followA.IncludesEndmarker && !followB.IncludesEndmarker)
							followB.IncludesEndmarker = followB.IncludesEndmarker || followA.IncludesEndmarker
						}
					}
				}
			}
		}
	}

	return func(A NonTerminal) TerminalsAndEndmarker {
		f, ok := follow.Get(A)
		if !ok {
			panic(fmt.Sprintf("undefined non-terminal %s", A))
		}

		return *f
	}
}

// addNewNonTerminal generates and adds a new non-terminal symbol to the grammar.
// It does so by appending each of the provided suffixes to the given prefix, in order,
// until it finds a non-terminal that does not already exist in the set of non-terminals.
//
// If all generated non-terminals already exist, the function panics.
func (g CFG) addNewNonTerminal(prefix NonTerminal, suffixes ...string) NonTerminal {
	// Use the base prefix without any previosuly applied suffix.
	for _, suffix := range suffixes {
		prefix = NonTerminal(strings.TrimSuffix(string(prefix), suffix))
	}

	for _, suffix := range suffixes {
		nonTerm := NonTerminal(string(prefix) + suffix)
		if !g.NonTerminals.Contains(nonTerm) {
			g.NonTerminals.Add(nonTerm)
			return nonTerm
		}
	}

	panic(fmt.Sprintf("Failed to generate a new non-terminal for %s", prefix))
}

// orderTerminals orders the unordered set of grammar terminals in a deterministic way.
//
// The goal of this function is to ensure a consistent and deterministic order for any given set of terminals.
func (g CFG) orderTerminals() String[Terminal] {
	terms := make(String[Terminal], 0)
	for t := range g.Terminals.All() {
		terms = append(terms, t)
	}

	// Sort terminals alphabetically based on the string representation of them.
	sort.Quick[Terminal](terms, cmpTerminal)

	return terms
}

// orderTerminals orders the unordered set of grammar non-terminals in a deterministic way.
//
// The goal of this function is to ensure a consistent and deterministic order for any given set of non-terminals.
func (g CFG) orderNonTerminals() (String[NonTerminal], String[NonTerminal], String[NonTerminal]) {
	visited := make(String[NonTerminal], 0)
	isVisited := func(n NonTerminal) bool {
		for _, v := range visited {
			if v == n {
				return true
			}
		}
		return false
	}

	visited = append(visited, g.Start)

	// Reppeat until no new non-terminal is added to visited:
	//   For each production rule of the form A ‚Üí Œ±:
	//     If A is in visited, add all non-terminal in Œ± to visited.
	for updated := true; updated; {
		updated = false
		for head := range g.Productions.AllByHead() {
			for _, p := range g.Productions.Order(head) {
				if isVisited(p.Head) {
					for _, n := range p.Body.NonTerminals() {
						if !isVisited(n) {
							visited = append(visited, n)
							updated = true
						}
					}
				}
			}
		}
	}

	// Identify any unvisited non-terminals in the grammar.
	unvisited := make(String[NonTerminal], 0)
	for n := range g.NonTerminals.All() {
		if !isVisited(n) {
			unvisited = append(unvisited, n)
		}
	}

	// Sort unvisited non-terminals alphabetically based on the string representation of them.
	sort.Quick[NonTerminal](unvisited, cmpNonTerminal)

	allNonTerms := make(String[NonTerminal], 0)
	allNonTerms = append(allNonTerms, visited...)
	allNonTerms = append(allNonTerms, unvisited...)

	return visited, unvisited, allNonTerms
}
